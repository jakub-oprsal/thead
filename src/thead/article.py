'''
Placeholder class for article, provides basic interface and printing of output.
'''
from datetime import datetime
from itertools import chain

from .tex import *


def xmltag(tag, content, inline=False):
    if inline:
        return f'<{tag}>{content}</{tag}>\n'
    else:
        text = indent(''.join(content))
        return f'<{tag}>\n{text}</{tag}>\n'


class CCS:
    def __init__(self, concepts):
        self.concepts = concepts

    def tex(self):
        return ''.join(render_command('ccsdesc',
                    concept['desc'],
                    concept.get('significance'))
                for concept in self.concepts)

    def _xml_concept(self, concept):
        return xmltag('concept', (xmltag(f'concept_{key}', value, inline=True)
                                  for key, value in concept.items()))

    def xml(self):
        return xmltag('ccs2012', map(self._xml_concept, self.concepts))

    def render(self):
        return render_env('CCSXML', self.xml().strip()) + self.tex()


COMMENT = '''% Generated by <https://github.com/jakub-oprsal/thead> on {now}
%
% {title}
% by {authors}
%'''


class Article:
    provides = []

    def __init__(self, meta, recipe, args):
        self.cls = args.cls
        self.cname = args.cname
        self.anonymous = args.anonymous
        self.opts = args.opts
        self.include = args.include
        self.recipe = recipe
        self.__dict__.update(meta)
        
        self.headers = [self.render_comment]
        self.footers = [self.render_bib, self.end_document]

    def authors_list(self, short=False):
        def name(author):
            return short_name(author['name']) if short else author['name']
        names = map(name, self.authors)
        return join_and(names)

    def render_comment(self):
        return COMMENT.format(now = datetime.now().strftime('%d-%m-%Y %H:%M:%S'),
            title = self.title.upper(),
            authors = self.authors_list(short=True))

    def render_documentclass(self):
        return render_command(
                'documentclass',
                self.cname,
                ','.join(self.opts))

    def maketitle(self):
        return '\\maketitle\n'

    def begin_document(self):
        return render_command('begin', 'document')

    def end_document(self):
        return render_command('end', 'document')

    def macro(self):
        return ''.join((include(file) for file in self.recipe.header))

    def render_encs(self):
        return render_command('usepackage', 'inputenc', 'utf8') + \
               render_command('usepackage', 'fontenc', 'T1')

    def render_title(self):
        return render_command('title', self.title)

    def render_authors(self):
        return '\n'.join(map(self.render_author, self.authors))

    def render_abstract(self):
        try:
            return render_env('abstract', self.abstract.strip())
        except AttributeError:
            return None

    def render_keywords(self):
        try:
            return render_command('keywords', ", ".join(self.keywords))
        except AttributeError:
            return None

    def render_ccs2012(self):
        try:
            return CCS(self.ccs2012['concepts']).render()
        except AttributeError:
            return None

    def render_funding(self, command='thanks'):
        try:
            funding_note = '\n'.join(grant['note']
                    for grant in self.funding
                    if 'note' in grant)
            return render_command(command, funding_note)
        except AttributeError:
            return None

    def render_bib(self):
        if self.recipe.bib:
            return render_command('bibliographystyle', self.bibstyle) + \
                render_command('bibliography', ','.join(self.recipe.bib))
        else:
            return '% no bibliography information\n'

    def header(self):
        headers = (f() for f in self.headers if f() is not None)
        return '\n'.join(headers) + '\n'

    def body(self):
        _include = lambda fn: include(fn, end='\n', soft=not self.include)
        content = map(_include, self.recipe.content)
        if self.recipe.appendix:
            appendix = chain(('\n\\appendix\n',), map(_include, self.recipe.content))
        else:
            appendix = ()
        return chain(content, appendix)

    def footer(self):
        footers = (f() for f in self.footers if f() is not None)
        return '\n'.join(footers)

    def dump(self):
        yield self.header()
        yield from self.body()
        yield self.footer()
